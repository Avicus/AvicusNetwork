package net.avicus.atlas.module.chests;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.ToString;
import net.avicus.atlas.event.world.BlockChangeEvent;
import net.avicus.atlas.match.Match;
import net.avicus.atlas.module.Module;
import net.avicus.atlas.module.chests.generator.ChestGenerator;
import net.avicus.atlas.module.chests.generator.ChestRegenerateTask;
import net.avicus.atlas.module.groups.GroupsModule;
import net.avicus.compendium.countdown.CountdownManager;
import net.avicus.compendium.plugin.CompendiumPlugin;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.Chest;
import org.bukkit.block.DoubleChest;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.inventory.InventoryOpenEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryHolder;
import org.joda.time.Duration;

/**
 * The chests module is used to dynamically (re)generate items in containers based on various
 * conditions and at various times.
 */
@ToString(exclude = "match")
public class ChestsModule implements Module {

  /**
   * The match that this module exists in.
   */
  private final Match match;
  /**
   * List of chest generators
   */
  private final List<ChestGenerator> generators;
  /**
   * List of chests that have been generated
   */
  private final List<Location> generated;
  /**
   * List of player placed chests
   */
  private final List<Location> blacklist;
  /**
   * Map containing the number of times a chest has been generated
   */
  private final Map<Location, Integer> generatedCounts;
  /**
   * List of (re)generation tasks.
   */
  private final List<ChestRegenerateTask> regenerateTasks;

  /**
   * Constructor.
   *
   * @param match match that this module exists in
   * @param generators list of chest generators to be used during the match
   */
  public ChestsModule(Match match, List<ChestGenerator> generators) {
    this.match = match;
    this.generators = generators;
    this.generated = new ArrayList<>();
    this.blacklist = new ArrayList<>();
    this.generatedCounts = new HashMap<>();
    this.regenerateTasks = new ArrayList<>();
  }

  /**
   * Remove a block from the generated list.
   *
   * @param block block to remove
   */
  public void clearGenerated(Block block) {
    this.generated.remove(block);
  }

  @Override
  public void close() {
    CountdownManager manager = CompendiumPlugin.getInstance().getCountdownManager();
    this.regenerateTasks.forEach(manager::cancel);
  }

  /**
   * Populate a container.
   * <p>
   * <p>
   * Logic:
   * <ul>
   * <li>Will check first if the container is a chest or double chest.</li>
   * <li>Will check if the block should be generated by the module.</li>
   * <lI>Will loop through all of the loaded generators and see if any allow population.</lI>
   * <li>Will update generation counts.</li>
   * <li>Will start a generation countdown if one is present and is allowed to be started.</li>
   * </ul>
   * </p>
   */
  private void populateChest(InventoryHolder holder) {
    Inventory inventory;
    Block block;

    if (holder instanceof Chest) {
      inventory = ((Chest) holder).getBlockInventory();
      block = ((Chest) holder).getLocation().getBlock();
    } else if (holder instanceof DoubleChest) {
      inventory = holder.getInventory();
      block = ((DoubleChest) holder).getLocation().getBlock();
    } else {
      return;
    }

    if (this.generated.contains(block.getLocation()) || this.blacklist
        .contains(block.getLocation())) {
      return;
    }

    boolean generated = false;

    for (ChestGenerator generator : this.generators) {
      if (generator.shouldPopulate(this.match, block)) {
        generator.populate(inventory);
        this.generatedCounts
            .put(block.getLocation(), this.generatedCounts.getOrDefault(block, 0) + 1);

        int generatedCount = this.generatedCounts.get(block.getLocation());

        if (generator.getRegenerateCountdown().isPresent()) {
          Duration countdown = generator.getRegenerateCountdown().get();
          int regenerateCount = generator.getRegenerateCount();

          if (generatedCount <= regenerateCount) {
            ChestRegenerateTask task = new ChestRegenerateTask(this, block, countdown);
            CompendiumPlugin.getInstance().getCountdownManager().start(task);
            this.regenerateTasks.add(task);
          }
        }

        generated = true;
      }
    }

    if (generated) {
      this.generated.add(block.getLocation());
    }
  }

  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
  public void onChestCreate(BlockChangeEvent event) {
    if (event.getNewState().getType() == Material.CHEST) {
      this.blacklist.add(event.getBlock().getLocation());
    }
  }

  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
  public void onChestDestroy(BlockChangeEvent event) {
    if (!event.isToAir()) {
      return;
    }

    if (!(event.getOldState() instanceof InventoryHolder)) {
      return;
    }

    InventoryHolder holder = (InventoryHolder) event.getOldState();
    populateChest(holder);
    Block block = null;

    if (holder instanceof Chest) {
      block = ((Chest) holder).getLocation().getBlock();
    } else if (holder instanceof DoubleChest) {
      block = ((DoubleChest) holder).getLocation().getBlock();
    }

    if (block == null) {
      return;
    }

    this.blacklist.remove(block.getLocation());
    this.generated.remove(block.getLocation());
    this.generatedCounts.remove(block.getLocation());
  }

  @EventHandler(priority = EventPriority.LOWEST)
  public void onInventoryOpen(InventoryOpenEvent event) {
    InventoryHolder holder = event.getInventory().getHolder();

    GroupsModule groups = this.match.getRequiredModule(GroupsModule.class);
    if (!groups.isObserving((Player) event.getPlayer())) {
      populateChest(holder);
    }
  }
}
